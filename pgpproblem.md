# the problem with pgp and public key infrastructure and multiple devices

## essentially, there are two sides of it: 

1. People are not 1:1 with devices, so key custodianship is hard. For example, should I store my private key on my mobile device? the OS only supports one user, so when I hand it over unlocked to someone, what level of trust and access am I really delegating? Think, for example, of the scene from Lost in Space where the pistols have safety locks, but a social engineering trick is used to get the legitimate owner to unlock it and transfer it to an attacker, which then uses the owner's own gun to kidnap them.
2. people may want to delegate certain decisions to various agents. for example, I allow my imcoming email messages to be filtered for spam, sorted based on rules I've defined, and indexed for later search and retrieval. I want to be able to place some trust in my system to do these things for me before I ever directly interact with the messages, for practical reasons. In a military scenario, think about a general decrypting their own messages. In reality, probably a lower level sigint officer handles the messages and then relies on internal security and controls to protect the message beyond a certain point of custody.

## It seems to me a possible approach is establishing multiple security principals:

1. I place my primary public/private keypair on a server I have reason to trust. For example, it might be on physical hardware I own running software I trust in a location with good enough physical security, like a Raspberry PI in my garage or an off-shore data center. For most of my communication, this is sufficient. People send me messages to that public key. My server is then able to decrypt and verify the messages and then handle whatever sort of action is called for - such as sending a reply, deleting a spam message, sending me a push notification. Communications between my terminal devices and that server could be protected by some other sort of certificate-based keys via Transport Layer Security. I'm operating within my security perimeter, to use the analogy of the general, communicating with my signals corps.

2. From time to time, a certain message may be more sensitive, or I may need to send a message with a stronger signature. I have a separate keypair issued for each terminal I carry with me, for example my mobile or my laptop. In the popular television series Battlestar Galactica, from time to time ship-to-ship communication needs to be directed to the ranking officer of the ship. This is directed to "$shipName Actual", for example, "Galactica Actual". To prevent disclosure for incoming messages, a nested relay envelope could be used - that is, the actual plaintext is first encrypted with my "actual" public key, then again with my security principal's public key. To a third party observer, it's the same as any other message being sent to my security principal. My security principal can then decrypt it and forward it to my device which has the corresponding "Actual" key.

3. For each device I own and use, I would issue a new "Actual" keypair and publicize the corresponding public key. Since the key would be unique to the device, there is a certain amount of disclosure that goes along with sending "Actual" messages from that device - no more pretending to be on your mobile to excuse typos! However, the sender would not have to know which device they are sending to, since they could encrypt the message to multiple recipients for each of the recipient's publicized "Actual" keys. This potentially creates an exposure weakness, since there are more keys which could potentially be compromised. The problem of key revocation is not addresssed with this scheme, and other "web of trust" verification and publication schemes would be necessary to ensure revocations are issued in a timely fashion - for example, if a device is lost.

4. There are still problems around key lifespan (related to perfect forward secrecy) which are common if not inherent in PGP-based systems: keys need to be rotated frequently. If a key is compromised such that an attacker has a private key, they can decrypt all communication which was ever encrypted for that key. This exposure is increased for messages being sent to multiple recipient keys, as described in multiple devices above in 3. Thus, when any "Actual" device is lost, all of the devices should revoke and re-issue their keys.

5. Short-lived keys make verification of authenticity hard. Some systems claim this as a benefit, under the name "repudiability". Suppose that we want the ability to have strong, verifiable signatures but reduce our exposure as described in 4, through a combination of short-lived and mass-revoked keys. An accurate, unforgeable clock becomes necessary so that signatures can be verified as having been issued during the timestamp during which the key was valid. Here, we can turn to log-based techniques using globally- or mass-replicated write-only logs. Outgoing messages could be signed with the sender's Actual key. A hash of the outgoing message could then also be sent to the public log servers, which act as a digital "notary". Since anyone can observe the entries on this log, they get an approximate ordering of events which in practice forms a "good enough" time stamp, which can be used to verify that A) a certain key was used to sign B) a certain message at C) a certain time and further D) as that time the signing key was valid.


